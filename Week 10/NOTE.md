# 浏览器工作原理

## 排版

排版——layout，有时也叫布局

采用flex排版，为大家实现一个排版算法（第二代排版技术）

排版技术：
第一代：包含了position、display、float
第二代：flex，接近人的设计思维
第三代：grid，更强大

选择第二代是因为容易实现，能力不算太差

### 根据浏览器属性进行排版

这一步做了准备工作，帮我们处理掉了flexDirection和wrap的属性，帮我们把width height left right top bottom等抽象成了main axis、cross axis的属性

### 收集元素进行

计算元素位置的一个重要工作
分行算法中心思想：
1. 根据主轴的尺寸把元素分进行，如果说设置了no-wrap，就会强行分配进第一行（分行算法）
2. 分行完成后，才可以进行后续的计算

### 计算主轴方向

根据flex的属性来计算每一行里面的尺寸
* 找出所有Flex元素
* 把主轴方向的剩余尺寸按比例分配给这些元素
* 按剩余空间为负数，所有flex元素为0，等比压缩剩余元素

### 计算交叉轴方向

* 根据每一行中最大元素尺寸计算行高
* 根据行高align-self（子元素的属性）和align-items（父元素的属性），确定元素具体位置

### 绘制单个元素

node.js没有图形封装，所以用images这个库来替代
* 绘制徐需要一个图形环境
* 我们这里才用了node包images
* 绘制在一个viewport上进行
* 与绘制相关的属性：background-color、border、background-image等
复杂点的渲染得在WebGL里进行

### 绘制DOM树

* 递归调用子元素的绘制方法完成DOM树的绘制
* 忽略一些不需要绘制的节点
* 实际浏览器中，文字绘制是难点，需要依赖自体库，我们这里忽略
* 实际浏览器中，还会对一些图层做ompositing，我们这里也忽略了

# 1~10周的学习总结

* 递归的重要性（其实在之前的工作中、刷算法的过程中，这个体会很深，能节约不少代码量）
* 知识梳理形成脑图（其实这一点我还是很不足的，那节课学得也不是很好，知识的系统性需要加强）
* 状态机的使用模式（这个我感觉是开展了我的眼界～）
* 对字符串match正则表达和RegExp的联合使用有了了解
* toybrowser了解到了flex大致的实现